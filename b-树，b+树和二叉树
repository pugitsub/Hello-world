前言：
    二叉查找树的时间复杂度是O(log N)，查找效率已经算高了，但也有其解决不了的问题，所以出现了b树和b+树，Ｂ树和Ｂ＋树的出现是因为另外一个问题，
    那就是磁盘ＩＯ；众所周知，ＩＯ操作的效率很低，那么，当在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐一加载磁盘页，
    每个磁盘页对应树的节点。造成大量磁盘ＩＯ操作（最坏情况下为树的高度）。平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。
　　所以，我们为了减少磁盘ＩＯ的次数，就你必须降低树的深度，将“瘦高”的树变得“矮胖”。一个基本的想法就是：
　　（1）每个节点存储多个元素
　　（2）摒弃二叉树结构，采用多叉树

　　这样就引出来了一个新的查找树结构 ——多路查找树。 根据AVL给我们的启发，一颗平衡多路查找树(B~树)自然可以使得数据的查找效率保证在O(logN)这样的对数级别上。
 
b树和b+树的区别：
  b+树在查找上优于b树，b+树是b树的一个变种，但是b+树和b树的查找都类似二叉查找树。
  （1）不同的是，Ｂ＋树中间节点没有卫星数据（索引元素所指向的数据记录），只有索引，而Ｂ树每个结点中的每个关键字都有卫星数据；
  这就意味着同样的大小的磁盘页可以容纳更多节点元素，在相同的数据量下，Ｂ＋树更加“矮胖”，ＩＯ操作更少。需要补充的是，
  在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。
  （2）其次，因为卫星数据的不同，导致查询过程也不同；Ｂ树的查找只需找到匹配元素即可，最好情况下查找到根节点，最坏情况下查找到叶子结点，
  所说性能很不稳定，而Ｂ＋树每次必须查找到叶子结点，性能稳定
  （3）在范围查询方面，B+树的优势更加明显：
　　B树的范围查找需要不断依赖中序遍历。首先二分查找到范围下限，在不断通过中序遍历，知道查找到范围的上限即可。整个过程比较耗时。
　　而B+树的范围查找则简单了许多。首先通过二分查找，找到范围下限，然后同过叶子结点的链表顺序遍历，直至找到上限即可，整个过程简单许多，效率也比较高
  
补充：中序遍历：中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。若二叉树为空则结束返回，否则：
（1）中序遍历左子树
（2）访问根结点
（3）中序遍历右子树
java代码实现：
class TreeNode{
    public int data;
    public TreeNode leftChild;
    public TreeNode rightChild;
    public static void inOrderTraversal(TreeNode node){
        if(node == null){
            return;
        }else{
            inOrderTraversal(node.leftChild);
            System.out.println(node.data);
            inOrderTRaversal(node.rightChild);
        }
    }
}

B+树相比B树的优势：
　　1.单一节点存储更多的元素，使得查询的IO次数更少；
　　2.所有查询都要查找到叶子节点，查询性能稳定；
　　3.所有叶子节点形成有序链表，便于范围查询。
  
  
二叉树：
  类型
    (1)完全二叉树——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。
    (2)满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。
    (3)平衡二叉树——平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
  辨析
    二叉树是树的一种特殊情形，是一种更简单而且应用更加广泛的树。
  存储结构：
    顺序存储方式：二叉树的顺序存储结构中节点的存放次序是：对该树中每个节点进行编号，其编号从小到大的顺序就是节点存放在连续存储单元的先后次序。
    链表存储方式：
